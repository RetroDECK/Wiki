# RetroDECK API Development

The RetroDECK API is a way for outside applications to get any information or perform any actions they need through the code Framework to be functional as a Configurator.

Currently the API is only accessible either through named pipes or internally in the Framework itself. Future methods of message transport may be added in the future.
Communication

---

## Communication with the API

If you would like to communicate with the RetroDECK API, follow this process:

- If RetroDECK is not currently running, the API server can be started by using the command:
    `flatpak run net.retrodeck.retrodeck --api`

- If RetroDECK is currently running, the server should already be started. This can be validated by looking for this specific named pipe:
    `~/.var/app/net.retrodeck.retrodeck/config/retrodeck/api/retrodeck_api_pipe`

This is the "listening" pipe used by the API, and all requests will enter the system through this pipe.

The client making the request must then generate a unique (but arbitrary) "request ID" which will be used to identify the response as well as the correct response pipe. The client must create this pipe itself, named with the following structure:
    `~/.var/app/net.retrodeck.retrodeck/config/retrodeck/api/response_{request_id}`

After the API server has completed its response, it will remove this response pipe itself.

---

## API Request Structure

Every API request consists of a single JSON object which contains all the needed information for the request.
Required keys:

- **action** - The desired action to be processed for the request. This splits the request into one of three classes: "`get`", "`se`t" or "`do`".

- **request** - The specific request to be processed

- **version** - This is a key to identify what version of the RetroDECK API you are attempting to interact with. Currently the only valid option is "1.0", but this is a placeholder for possible future upgrades and backwards compatibility.

- **request_id** - The unique (but arbitrary) request ID generated by the client.
Optional keys:

- **data** - This is an object containing additional information regarding the action to be taken. This can be a single key/value pair, or a series of nested objects each with their own information.

### Example request

Here is an example of a full request for the RetroDECK API. The request is for a list of all games that can be identified as being compressible into the zip format.

```
{
  "action": "get",
  "request": "compressible_games",
  "data": {
    "format": "zip"
  },
  "version": "1.0",
  "request_id": "12345"
}

API Response Structure
After receiving a proper request, the RetroDECK API will respond with this structure for a successful response:

{
  "status": "<status_report>",
  "result": {
   <response contents>
  },
  "request_id": "<request_id>"
}

or this structure in the case of an error:

{
  "status": "error",
  "message": "<error message>",
  "request_id": "<request_id>"
}

```

In this structure, these keys have the following meaning:

- **status** - Will return either "success" or "error", depending on the outcome of the request.

- **result** - Will be a single or array of objects containing the response information.

- **message** - Only for error responses, will contain some information about the nature of the error.

- **request_id** - The request ID of the request that prompted this response.

If using named pipes for communication, after a response is processed the API server will remove the response pipe, indicating that the API transaction is complete.

### Example responses

Here is an example of a full response for the RetroDECK API, responding to the previous example request for zip-compressible games data.


```
{
  "status": "success",
  "result": [
    {
      "game": "/home/deck/retrodeck/roms/snes/3 Ninjas Kick Back (USA).sfc",
      "compression": "zip"
    },
    {
      "game": "/home/deck/retrodeck/roms/snes/Aero Fighters (USA).sfc",
      "compression": "zip"
    }
  ],
  "request_id": "client_1746640357_8454"
}

```

In this example, the "result" information is an array of objects, each with their own key/value pairs. The result data will vary depending on request, but will always reside within the "result" key.

Here is another example request, for the value of a setting named `rdhome` in the `paths` section of the `retrodeck.cfg` file, using the config file format retrodeck:

```

{
  "action": "get",
  "request":"setting_value",
  "data": {
    "setting_file": "/var/config/retrodeck/retrodeck.cfg",
    "setting_name": "rdhome",
    "system_name": "retrodeck",
    "section_name": "paths"
    },
  "version": "1.0",
  "request_id": "54321"
}

and the response for that request:

{
  "status": "success",
  "result": {
    "setting_name": "rdhome",
    "setting_value": "/home/deck/retrodeck"
  },
  "request_id": "54321"
}

```

----

## API Request Group - GET

The GET group

---

### compressible_games

**Description:**

This call will return an array of objects of any game found to be compatible with the compression system for the provided format. If "all" is specified for the format, all compatible compression methods will be checked.

**Applicable data keys:** 

- format

**Additional details for applicable data keys:**

Valid values for key "format":

- **chd** - CHD compression, typically used by disc-based systems such as PSP

- **rvz** - RVZ compression, specific to Dolphin-based systems such as GameCube

- **zip** - ZIP compression, compatible with many systems

- **all** - Will check all files for compatibility with all types of compression

Additional details on what systems are compatible with what compression formats can be found on the RetroDECK wiki.

Additional considerations:
Depending on the size of the library, this process can take a lot of time, so consider wrapping it in some kind of spinner so the user knows to wait.

#### compressible_games - example request

```

{
  "action": "get",
  "request": "compressible_games",
  "data": {
    "format": "zip"
  },
  "version": "1.0",
  "request_id": "12345"
}

```

#### compressible_games - success response

```

{
  "status": "success",
  "result": [
    {
      "game": "/home/deck/retrodeck/roms/snes/3 Ninjas Kick Back (USA).sfc",
      "format": "zip"
    },
    {
      "game": "/home/deck/retrodeck/roms/snes/Aero Fighters (USA).sfc",
      "format": "zip"
    },
    {
      "game": "/home/deck/retrodeck/roms/snes/Aero the Acro-Bat (USA).sfc",
      "format": "zip"
    }
  ],
  "request_id": "<request_id>"
}

```

#### compressible_games - failure response

```

{
  "status": "error",
  "result": "the compressible games list could not be generated",
  "request_id": "<request_id>"
}

```

---

### components

**Description:**

This call will return an array of objects containing basic information for every installed component. Returned information includes the internal "machine-readable" name for the component, a human-friendly name and description and a list of all systems emulated by the component.

**Applicable data keys:** None

**Additional considerations:** None

#### compressible_games - example request


```

{
  "action": "get",
  "request": "components",
  "version": "1.0",
  "request_id": "<request_id>"
}

```

#### compressible_games - success response


```

{
  "status": "success",
  "result": [
    {
      "component_name": "retrodeck",
      "component_friendly_name": "RetroDECK",
      "description": "RetroDECK Framework",
      "emulated_system": "none",
      "path": "/app/retrodeck/components/retrodeck",
      "compatible_presets": "none"
    },
    {
      "component_name": "ppsspp",
      "component_friendly_name": "PPSSPP",
      "description": "PlayStation Portable Emulator",
      "emulated_system": "psp",
      "path": "/app/retrodeck/components/ppsspp",
      "compatible_presets": {
        "cheevos": [
          "false",
          "true"
        ],
        "cheevos_hardcore": [
          "false",
          "true"
        ]
      }
    },
    {
      "component_name": "retroarch",
      "component_friendly_name": "RetroArch",
      "description": "Libretro Multi-emulator Frontend",
      "emulated_system": "retroarch",
      "path": "/app/retrodeck/components/retroarch",
      "compatible_presets": {
        "cheevos": [
          "false",
          "true"
        ],
        "cheevos_hardcore": [
          "false",
          "true"
        ],
        "snes9x-current_libretro": {
          "borders": [
            "false",
            "true"
          ],
          "widescreen": [
            "false",
            "true"
          ]
        },
        "gambatte_libretro": {
          "borders": [
            "false",
            "true"
          ],
          "rewind": [
            "false",
            "true"
          ]
        }
      }
    },
    {
      "component_name": "steam-rom-manager",
      "component_friendly_name": "Steam ROM Manager",
      "description": "Used to sync RetroDECK favorites and Launcher with Steam",
      "emulated_system": "none",
      "path": "/app/retrodeck/components/steam-rom-manager"
    }
  ],
  "request_id": "<request_id>"
}
Failure response:
{
  "status": "error",
  "result": "the current component information could not be read",
  "request_id": "<request_id>"
}

```

---

### retrodeck_settings

**Description:**

This call will return all the current settings in the retrodeck.cfg config file. This will include internal paths to locations like the ROMs folder, the Saves folder, the BIOS folder etc. As these locations can be somewhat arbitrary, this is a useful call if the client is planning to reference them directly later. The output will also contain all of the internal RetroDECK setting options (such as logging level) as well as the current state for every preset for every component.

**Applicable data keys:** None

**Additional considerations:** None

#### retrodeck_settings - example request

```

{
  "action": "get",
  "request": "retrodeck_settings",
  "version": "1.0",
  "request_id": "<request_id>"
}

```


#### retrodeck_settings - success response


```

{
  "status": "success",
  "result": {
    "version": "<some_version>",
    "paths": {
      "rdhome": "/home/deck/retrodeck",
      "roms_folder": "/home/deck/retrodeck/roms",
      "saves_folder": "/home/deck/retrodeck/saves",
      "states_folder": "/home/deck/retrodeck/states",
      "shaders_folder": "/home/deck/retrodeck/shaders",
      "bios_folder": "/home/deck/retrodeck/bios",
      "backups_folder": "/home/deck/retrodeck/backups",
      "media_folder": "/home/deck/retrodeck/ES-DE/downloaded_media",
      "themes_folder": "/home/deck/retrodeck/ES-DE/themes",
      "logs_folder": "/home/deck/retrodeck/logs",
      "screenshots_folder": "/home/deck/retrodeck/screenshots",
      "mods_folder": "/home/deck/retrodeck/mods",
      "texture_packs_folder": "/home/deck/retrodeck/texture_packs",
      "borders_folder": "/home/deck/retrodeck/borders",
      "cheats_folder": "/home/deck/retrodeck/cheats",
      "sdcard": "/some/other/path"
    },
    "options": {
      "power_user_warning": "false",
      "desktop_mode_warning": "true",
      "low_space_warning": "false",
      "update_check": "true",
      "update_repo": "",
      "branch": "",
      "update_ignore": "",
      "cloud_saves": "false",
      "multi_user_mode": "false",
      "ask_default_user": "true",
      "default_user": "",
      "developer_options": "true",
      "akai_ponzu": "false",
      "cheevos_login": "false",
      "font": "1",
      "kiroi_ponzu": "false",
      "logging_level": "debug",
      "portmaster_reload_esde": "true",
      "portmaster_show": "false",
      "sound_effects": "true",
      "steam_sync": "true",
      "volume_effects": "10"
    },
    "presets": {
      "cheevos": {
        "ppsspp": "true",
        "retroarch": "true"
      },
      "cheevos_hardcore": {
        "ppsspp": "false",
        "retroarch": "false"
      },
      "borders": {
        "retroarch.cores": {
          "snes9x-current_libretro": "false",
          "gambatte_libretro": "false"
        }
      },
      "widescreen": {
        "retroarch.cores": {
          "snes9x-current_libretro": "false"
        }
      },
      "rewind": {
        "retroarch.cores": {
          "gambatte_libretro": "false"
        }
      }
    }
  },
  "request_id": "<request_id>"
}
Failure response:
{
  "status": "error",
  "result": "the retrodeck config file could not be read",
  "request_id": "<request_id>"
}

```

---

### incompatible_presets

**Description:**

This call will return a key/value list of all known incompatible presets. As some presets cannot be enabled at the same time as other presets (such as "borders" and "widescreen"), the output can be used to take these incompatibilities into account in a GUI environment. For example, a user could be pre-warned about trying to enable a preset while another incompatible preset is already enabled.

**Applicable data keys:** None

**Additional considerations:** None

#### incompatible_presets -  example request

```

{
  "action": "get",
  "request": "incompatible_presets",
  "version": "1.0",
  "request_id": "<request_id>"
}

```

#### incompatible_presets - success response


```

{
  "status": "success",
  "result": {
    "borders": "widescreen",
    "other_preset_1": "other_preset_2"
  },
  "request_id": "<request_id>"
}

```

#### incompatible_presets - failure response

```

{
  "status": "error",
  "result": "the incompatible presets list could not be read",
  "request_id": "<request_id>"
}

```

---

### setting_value

**Description:**

This call allows for getting the value of a specific setting name from any known config file. The name of the config file must be known, along with the setting name, any applicable setting file section header and the internal "system" name of the component.

Applicable data keys:

- **setting_file** - A full path or known variable name to the setting file to reference.

- **setting_name** - The specific setting name to reference.

- **system_name** - The RetroDECK-internal name of the system being referenced. This will match the component name from API functions such as "get all_components".

- **section_name** - (Optional) the section of the config file where the setting_name is found. Can be left blank or omitted entirely if the setting is not found in a specific section.

**Additional considerations:**

It is possible to use known variable names (such as $rd_conf) for the setting_file key value as well, as they will be resolved to the true path internally. These names must be in Bash-compatible format and start with a $.

#### setting_value - example request

```

{
  "action": "get",
  "request": "setting_value",
  "data": {
    "setting_file": "<setting_file>",
    "setting_name": "<setting_name>",
    "system_name": "<system_name>",
    "section_name": "<section_name>"
  },
  "version": "1.0",
  "request_id": "<request_id>"
}

Example responses:
Success response:
{
  "status": "success",
  "result": {
    "setting_name": "<setting_name>",
    "setting_value": "<setting_value>"
  },
  "request_id": "<request_id>"
}
Failure response:
{
  "status": "error",
  "result": "the value of <setting_name> could not be read",
  "request_id": "<request_id>"
}

```

---

### current_preset_state

**Description:**

This call will return the current information for any given preset, component or combination of both. A value of "any" is also acceptable for the "preset" key value, and if the component key value is omitted it will return a list of all components compatible with the given preset. Specifying "all" for the preset with no specified component will return the state of all presets for all components.

**Applicable data keys:**

- **preset** - A specific preset name, or "any" to gather data for all presets.

- **component** - (Optional) A specific component to gather data for given preset. Can be left blank or omitted entirely, at which point data will be gathered for all applicable components.

**Additional considerations:**  None

#### current_preset_state - example request


#### current_preset_state - example response 


---

### bios_file_status

**Description:**

This call will return an array of objects containing information regarding the state of all known BIOS files under the intention of this data being shown in some kind of menu list. The returned information includes BIOS file name, what systems the BIOS file applies to, if the BIOS file was found in the required location, if the BIOS file matches a known-good MD5 hash, a desription of the files use, what paths the file is expected at and a list of any known MD5 hashes for that specific file. The files being checked and all their related data comes from an internal RetroDECK database.

**Applicable data keys:** None

**Additional considerations:**

Depending on the number of BIOS files the user has, this process can take a lot of time, so consider wrapping it in some kind of spinner so the user knows to wait.

#### bios_file_status - example request

```

{
  "action": "get",
  "request": "bios_file_status",
  "version": "1.0",
  "request_id": "<request_id>"
}

```

### bios_file_status - successful response

```

{
  "status": "success",
  "result": [
    -- additional output trimmed --
    {
      "file": "tc2068-0.rom",
      "systems": "zxspectrum",
      "file_found": "No",
      "md5_matched": "No",
      "description": "ZX Spectrum BIOS",
      "paths": "/home/deck/retrodeck/bios",
      "known_md5_hashes": "55d462fccc6c536037404ef4ced08bec"
    },
    {
      "file": "tc2068-1.rom",
      "systems": "zxspectrum",
      "file_found": "No",
      "md5_matched": "No",
      "description": "ZX Spectrum BIOS",
      "paths": "/home/deck/retrodeck/bios",
      "known_md5_hashes": "575d203c6e15e679fba0b73f854ec7a2"
    }
  ]
  "request_id": "<request_id>"
}

```

#### bios_file_status - failure response


```

{
  "status": "error",
  "result": {
    "response": "the bios file status could not be checked"
  },
  "request_id": "<request_id>"
}

```

---

###  multifile_game_structure

**Description:**

This call will check for any common multi-file game structure issues and return an array of objects of any that are found. If none are found, the command will complete with a "success" status, if issues are found it will complete with an "error" status.

**Applicable data keys:** None

**Additional considerations:**

The output of this function is non-exhaustive and represents a best-effort to identify common multi-file game structure issues. Additional information regarding proper multi-file game strutures can be found on the RetroDECK wiki.


####  multifile_game_structure - example request

```

{
  "action": "get",
  "request": "multifile_game_structure",
  "version": "1.0",
  "request_id": "<request_id>"
}

```


####  multifile_game_structure - success response


```

{
  "status": "success",
  "result": "no multifile game structure issues found"
  "request_id": "<request_id>"
}

```

####  multifile_game_structure - failure response

```

{
  "status": "error",
  "result": [
    {
      "incorrect_file": "<incorrect file path>"
    },
    {
      "incorrect_file": "<incorrect file path 2>"
    }
  ],
  "request_id": "<request_id>"
}

```

---

## API Request Group - SET

The SET Group.

---

### preset_state

**Description:**

This call will set the state of any given preset for any given component to any given value, after performing compatibility prechecks. Supported components are any that are compatible with any number of presets. Supported presets are whatever the given component supports. Supported values are whatever are defined in that components manifest for that preset. As value state names can be arbitrary, this will vary from component to component, but all possible options are listed in the results of the API call "get all_components".

**Applicable data keys:**

- **component** - The name of the component, using the internal system name as referenced by other API calls such as "get all_components".

- **preset** - The name of the preset to be changed, using the internal preset name as referenced by other API calls such as "get current_preset_state".

- **state** - The new desired state to set the preset to.

- **cheevos_username** - (Optional) only needed if enabling a RetroAchivements-related preset, the username as provided by the user to log into the RetroAchivements system.

- **cheevos_token** -  (Optional) only needed if enabling a RetroAchivements-related preset, the token is provided upon successful login to the RetroAchivements system through the RetroDECK API call "do cheevos_login".

**Additional considerations:**

This call performs several compatibility prechecks prior to actually changing anything, such as if the supplied information is correct and that there are no other incompatible presets already enabled. An error message will be returned explaining why the request was rejected if any of the prechecks fail.

#### preset_state - example request

```

{
  "action": "set",
  "request": "preset_state",
  "data": {
    "component": "<component_name>",
    "preset": "<preset_name>",
    "state": "<new_preset_state>",
    "cheevos_username": "<cheevos_username>",
    "cheevos_token": "<cheevos_login_token>"
  },
  "version": "1.0",
  "request_id": "<request_id>"
}

```

#### preset_state - success response


```

{
  "status": "success",
  "result": "preset <preset_name> for component <component_name> was successfully changed to <state>"
  "request_id": "<request_id>"
}

```

#### preset_state - failure response

```

{
  "status": "error",
  "result": {
    "response": "desired state <state> for component <component_name> preset <preset_name> is invalid"
  },
  "request_id": "<request_id>"
}

```

### setting_value

**Description:**

This call will change the value of any given setting name in any given setting file. The structure is similar to the API call "get setting_value" only with an additional key for the new setting value.

**Applicable data keys:**

- setting_file** - A full path or known variable name to the setting file to reference.

- **setting_name** - The specific setting name to reference.

- **setting_value** - The new value to set the given setting to.

- **system_name** - The RetroDECK-internal name of the system being referenced. This will match the component name from API functions such as "get all_components".

- **section_name** - (Optional) the section of the config file where the setting_name is found. Can be left blank or omitted entirely if the setting is not found in a specific section.

**Additional considerations:**

It is possible to use known variable names (such as $rd_conf) for the setting_file key value as well, as they will be resolved to the true path internally. These names must be in Bash-compatible format and start with a $. The requested change will also be validated to have actually happened, and an error message returned if it could not be.

#### setting_value - example request


```

{
  "action": "set",
  "request": "setting_value",
  "data": {
    "setting_file": "<setting_file>",
    "setting_name": "<setting_name>",
    "setting_value": "<new_setting_value>",
    "system_name": "<system_name>",
    "section_name": "<section_name>"
  },
  "version": "1.0",
  "request_id": "<request_id>"
}

```

#### setting_value - success response


```

{
  "status": "success",
  "result": {
    "setting_name": "<setting_name>",
    "setting_value": "<new_setting_value>"
  },
  "request_id": "<request_id>"
}

```
#### setting_value - failure response

```

{
  "status": "error",
  "result": {
    "response": "setting value on <setting_name> was not able to be changed"
  },
  "request_id": "<request_id>"
}

```

### retrodeck_setting

**Description:**

This is an extension of the call "set setting_value", made to simplify changing internal RetroDECK settings. The process is the same but the data key set is simplified. All the current RetroDECK settings can be retrieved through the API call "get retrodeck_settings".

**Applicable data keys:**

- **setting_name** - The specific setting name to reference.

- **setting_value** - The new value to set the given setting to.

- **section_name** - (Optional) The section of the config file where the setting_name is found. Can be left blank or omitted entirely if the setting is not found in a specific section.

Additional considerations:
Although this call can alter the state of preset setting values in the retrodeck.cfg file directly, it will not actually apply the preset settings themselves, so should not be used in this way. The requested change will also be validated to have actually happened, and an error message returned if it could not be.

#### retrodeck_setting - example request

```

{
  "action": "set",
  "request": "setting_value",
  "data": {
    "setting_name": "<setting_name>",
    "setting_value": "<new_setting_value>",
    "section_name": "<section_name>"
  },
  "version": "1.0",
  "request_id": "<request_id>"
}

```

#### retrodeck_setting - success response

```

{
  "status": "success",
  "result": {
    "setting_name": "<setting_name>",
    "setting_value": "<new_setting_value>"
  },
  "request_id": "<request_id>"
}

```

#### retrodeck_setting - failure response


```

{
  "status": "success",
  "result": {
    "response": "setting value on <setting_name> was not able to be changed"
  },
  "request_id": "<request_id>"
}

```

## API Request Group - DO

### compress_games

**Description:**

This call will compress one or more provided games into the specified compression format. The provided data will include single key/value pairs as well as game objects containing their own keys and values, matching the output structure of the API call "get compressible_games".

**Applicable data keys:**

- **post_compression_cleanup** - (Optional) either "true" or "false", setting this value to "true" will have the compression process remove the original game files once they are compressed and validated that the compression completed successfully. This key can be blank or omitted entirely and will default to "false" unless specified as "true".

- **games [ ]** - This is a parent array of objects for the games to be compressed.

- **game** - This is the path to the game to be compressed, in its own object within the games[] array.

- **format** - This is the specified format to compress the game into, held within the same object as the desired game.

**Additional considerations:**

No compatibility checks are performed for this part of the compression process, so ensure the games you specify match a compatible compression format, or incorrect compressions may occur. Compression validation can be performed on all games with the API call "get compressible_games", and additional information on what systems support what compression formats can be found on the RetroDECK wiki.

#### compress_games - example request

```

{
  "action": "do",
  "request": "compress_games",
  "data": {
    "post_compression_cleanup": "true",
    "games": [
      {
        "game": "/home/deck/retrodeck/roms/snes/3 Ninjas Kick Back (USA).sfc",
        "format": "zip"
      },
      {
        "game": "/home/deck/retrodeck/roms/snes/Aero Fighters (USA).sfc",
        "format": "zip"
      }
    ]
  }
}

```

#### compress_games - success response


```
{
  "status": "success",
  "result": "the compression process is complete"
  "request_id": "<request_id>"
}

```
#### compress_games - failure response

```
{
  "status": "error",
  "result": "the compression process could not be completed"
  "request_id": "<request_id>"
}

```

### reset_component

**Description:**

This call will perform a "reset" on the given component. The reset actions are component-specific and can be found in the matching "prepare_component.sh" file.

**Applicable data keys:**

- **component** - The name of the component, using the internal system name as referenced by other API calls such as "get all_components".

**Additional considerations:** None

#### reset_component - example request

```

{
  "action": "do",
  "request":"reset_component",
  "data": {
    "component": "<component_name>
  },
  "version": "1.0",
  "request_id": "<request_id>"
}

```

#### reset_component - success response


```

{
  "status": "success",
  "result": "reset of component <component_name> is complete"
  "request_id": "<request_id>"
}

```

#### reset_component - failure response

```

{
  "status": "error",
  "result": "reset of component <component_name> could not be completed"
  "request_id": "<request_id>"
}

```

### install

**Description:**
This call will perform an "install" for the provided RetroDECK package, such as the Steam Controller Profile. A list of the available packages is maintained on the RetroDECK wiki.

Applicable data keys:**

- **package_name** - The internal name of the package to be installed.

**Additional considerations:** None

#### install - example request

```

{
  "action": "do",
  "request":"install",
  "data": {
    "package_name": "<package_name>"
  },
  "version": "1.0",
  "request_id": "<request_id>"
}

```

#### install - success response


```

{
  "status": "success",
  "result": "<package_name> installed"
  "request_id": "<request_id>"
}

```

#### install - failure response

```

{
  "status": "error",
  "result": "unknown package name: <package_name>"
  "request_id": "<request_id>"
}

```

### cheevos_login

**Description:**

This call will attempt to perform a RetroAchivements login with the provided information and return the supplied information from the RetroAchivements API, as well as a login timestamp. This information can then be used to enable RetroAchivements-related presets directly.

Applicable data keys:

- **username** - The RetroAchivements username to be used in the login attempt.
- **password** - The RetroAchivements password to be used in the login attempt.

**Additional considerations:**

If the login information provided is accepted by the RetroAchievements login system, the returned result will include a login token and timestamp, which most RA-capable components will require for the "cheevos" preset. That information can then be passed along to the "set preset_state" RetroDECK API call in the appropriate keys.
 
#### cheevos_login - example request

```

{
  "action": "do",
  "request":"cheevos_login",
  "data": {
    "username": "<username>",
    "password": "<password>"
  },
  "version": "1.0",
  "request_id": "<request_id>"
}

```

#### cheevos_login - success response


```

{
  "status": "success",
  "result": {
    "Success": true,
    "User": "<username>",
    "AvatarUrl": "https://media.retroachievements.org/UserPic/<username>.png",
    "Token": "<login token>",
    "Score": 0,
    "SoftcoreScore": 0,
    "Messages": 0,
    "Permissions": 1,
    "AccountType": "Registered",
    "Timestamp": "<login timestamp>"
  },
  "request_id": "<request_id>"
}

```


#### cheevos_login - failure response


```

{
  "status": "error",
  "result": "login failed",
  "request_id": "<request_id>"
}

```


