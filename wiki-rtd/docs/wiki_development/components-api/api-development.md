Overview
The RetroDECK API is a way for outside applications to get any information or perform any actions they need through the code Framework to be functional as a Configurator.

Currently the API is only accessible either through named pipes or internally in the Framework itself. Future methods of message transport may be added in the future.
Communication
If you would like to communicate with the RetroDECK API, follow this process:

- If RetroDECK is not currently running, the API server can be started by using the command:
    flatpak run net.retrodeck.retrodeck --api

- If RetroDECK is currently running, the server should already be started. This can be validated by looking for this specific named pipe:
    ~/.var/app/net.retrodeck.retrodeck/config/retrodeck/api/retrodeck_api_pipe

This is the "listening" pipe used by the API, and all requests will enter the system through this pipe.

The client making the request must then generate a unique (but arbitrary) "request ID" which will be used to identify the response as well as the correct response pipe. The client must create this pipe itself, named with the following structure:
    ~/.var/app/net.retrodeck.retrodeck/config/retrodeck/api/response_{request_id}

After the API server has completed its response, it will remove this response pipe itself.

API Request Structure
Every API request consists of a single JSON object which contains all the needed information for the request.
Required keys:
"action" - The desired action to be processed for the request. This splits the request into one of three classes: "get", "set" or "do".
"request" - The specific request to be processed
"version" - This is a key to identify what version of the RetroDECK API you are attempting to interact with. Currently the only valid option is "1.0", but this is a placeholder for possible future upgrades and backwards compatibility.
"request_id" - The unique (but arbitrary) request ID generated by the client.
Optional keys:
"data" - This is an object containing additional information regarding the action to be taken. This can be a single key/value pair, or a series of nested objects each with their own information.

Example request:
Here is an example of a full request for the RetroDECK API. The request is for a list of all games that can be identified as being compressible into the zip format.

{
  "action": "get",
  "request": "compressible_games",
  "data": {
    "format": "zip"
  },
  "version": "1.0",
  "request_id": "12345"
}

API Response Structure
After receiving a proper request, the RetroDECK API will respond with this structure for a successful response:

{
  "status": "<status_report>",
  "result": {
   <response contents>
  },
  "request_id": "<request_id>"
}

or this structure in the case of an error:

{
  "status": "error",
  "message": "<error message>",
  "request_id": "<request_id>"
}

In this structure, these keys have the following meaning:
"status" - Will return either "success" or "error", depending on the outcome of the request.
"result" - Will be a single or array of objects containing the response information.
"message" - Only for error responses, will contain some information about the nature of the error.
"request_id" - The request ID of the request that prompted this response.

If using named pipes for communication, after a response is processed the API server will remove the response pipe, indicating that the API transaction is complete.

Example response:
Here is an example of a full response for the RetroDECK API, responding to the previous example request for zip-compressible games data.

{
  "status": "success",
  "result": [
    {
      "game": "/home/deck/retrodeck/roms/snes/3 Ninjas Kick Back (USA).sfc",
      "compression": "zip"
    },
    {
      "game": "/home/deck/retrodeck/roms/snes/Aero Fighters (USA).sfc",
      "compression": "zip"
    }
  ],
  "request_id": "client_1746640357_8454"
}

In this example, the "result" information is an array of objects, each with their own key/value pairs. The result data will vary depending on request, but will always reside within the "result" key.
Additional Request / Response Examples:
Here is another example request, for the value of a setting named "rdhome" in the "paths" section of the "retrodeck.cfg" file, using the config file format "retrodeck":

{
  "action": "get",
  "request":"setting_value",
  "data": {
    "setting_file": "/var/config/retrodeck/retrodeck.cfg",
    "setting_name": "rdhome",
    "system_name": "retrodeck",
    "section_name": "paths"
    },
  "version": "1.0",
  "request_id": "54321"
}

and the response for that request:

{
  "status": "success",
  "result": {
    "setting_name": "rdhome",
    "setting_value": "/home/deck/retrodeck"
  },
  "request_id": "54321"
}
API Command Reference:
API Request Group - GET
"compressible_games"

Description:
This call will retrurn an array of objects of any game found to be compatible with the compression system for the provided format. If "all" is specified for the format, all compatible compression methods will be checked.

Required data keys: 
format

- Additional details for required data keys: 
Valid values for key "format":
chd - CHD compression, typically used by disc-based systems such as PSP
rvz - RVZ compression, specific to Dolphin-based systems such as GameCube
zip - ZIP compression, compatible with many systems
all - Will check all files for compatibility with all types of compression
Additional details on what systems are compatible with what compression formats can be found on the RetroDECK wiki.

Additional considerations:
Depending on the size of the library, this process can take a lot of time, so consider wrapping it in some kind of spinner so the user knows to wait.

Example request:
{
  "action": "get",
  "request": "compressible_games",
  "data": {
    "format": "zip"
  },
  "version": "1.0",
  "request_id": "12345"
}

Example response:


"all_components"

Description:
This call will return an array of objects containing basic information for every installed component. Returned information includes the internal "machine-readable" name for the component, a human-friendly name and description and a list of all systems emulated by the component.

Required data keys: None

Additional considerations: None

Example request:


Example response:


"retrodeck_settings"

Description:
This call will return all the current settings in the retrodeck.cfg config file. This will include internal paths to locations like the ROMs folder, the Saves folder, the BIOS folder etc. As these locations can be somewhat arbitrary, this is a useful call if the client is planning to reference them directly later. The output will also contain all of the internal RetroDECK setting options (such as logging level) as well as the current state for every preset for every component.

Required data keys: None

Additional considerations: None

Example request:


Example response:


"incompatible_presets"

Description:
This call will return a key/value list of all known incompatible presets. As some presets cannot be enabled at the same time as other presets (such as "borders" and "widescreen"), the output can be used to take these incompatibilities into account in a GUI environment. For example, a user could be pre-warned about trying to enable a preset while another incompatible preset is already enabled.

Required data keys: None

Additional considerations: None

Example request:


Example response:


"setting_value"

Description:
This call allows for getting the value of a specific setting name from any known config file. The name of the config file must be known, along with the setting name, any applicable setting file section header and the internal "system" name of the component.

Required data keys:
setting_file
setting_name
system_name
section_name

- Additional details for required data keys:
setting_file - A full path or known variable name to the setting file to reference
setting_name - The specific setting name to reference
system_name - The RetroDECK-internal name of the system being referenced. This will match the component name from API functions such as "get all_components"
section_name (optional) - The section of the config file where the setting_name is found. Can be left blank or omitted entirely if the setting is not found in a specific section.

Additional considerations:
It is possible to use known variable names (such as $rd_conf) for the setting_file key value as well, as they will be resolved to the true path internally. These names must be in Bash-compatible format and start with a $.

Example request:


Example response:


"current_preset_state"

Description:
This call will return the current information for any given preset, component or combination of both. A value of "any" is also acceptable for the "preset" key value, and if the component key value is omitted it will return a list of all components compatible with the given preset. Specifying "all" for the preset with no specified component will return the state of all presets for all components.

Required data keys:
preset
component

- Additional details for required data keys:
preset - A specific preset name, or "any" to gather data for all presets
component (optional) - A specific component to gather data for given preset. Can be left blank or omitted entirely, at which point data will be gathered for all applicable components.

Additional considerations:  None

Example request:


Example response:


"bios_file_status"

Description:
This call will return an array of objects containing information regarding the state of all known BIOS files under the intention of this data being shown in some kind of menu list. The returned information includes BIOS file name, what systems the BIOS file applies to, if the BIOS file was found in the required location, if the BIOS file matches a known-good MD5 hash, a desription of the files use, what paths the file is expected at and a list of any known MD5 hashes for that specific file. The files being checked and all their related data comes from an internal RetroDECK database.

Required data keys: None

Additional considerations:
Depending on the number of BIOS files the user has, this process can take a lot of time, so consider wrapping it in some kind of spinner so the user knows to wait.

Example request:


Example response:


"multifile_game_structure"

Description:
This call will check for any common multi-file game structure issues and return an array of objects of any that are found. If none are found, the command will complete with a "success" status, if issues are found it will complete with an "error" status.

Required data keys: None

Additional considerations:
The output of this function is non-exhaustive and represents a best-effort to identify common multi-file game structure issues. Additional information regarding proper multi-file game strutures can be found on the RetroDECK wiki.

Example request:


Example response:


API Request Group - SET
"preset_state"

Description:

Required data keys:

Additional considerations:

Example request:


Example response:


"setting_value"

Description:

Required data keys:

Additional considerations:

Example request:


Example response:


"retrodeck_setting"

Description:

Required data keys:

Additional considerations:

Example request:

API Request Group - DO
"compress_games"

Description:

Required data keys:

Additional considerations:

Example:


Example response:


"reset_component"

Description:

Required data keys:

Additional considerations:

Example request:


Example response:


"install"

Description:

Required data keys:

Additional considerations:

Example request:


Example response:


"cheevos_login"

Description:

Required data keys:

Additional considerations:

Example request:


Example response:


